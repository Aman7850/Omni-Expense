{"version":3,"sources":["useReactiveValues.ts"],"names":["useReactiveValues","values","ref","current","map","value","push","Animated","Value","index","setValue","length","lastValue","i"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEO,MAAMA,iBAAiB,GAAIC,MAAD,IAAmC;AAClE;AACA,QAAMC,GAAG,GAAG,mBAAiC,IAAjC,CAAZ;;AACA,MAAIA,GAAG,CAACC,OAAJ,KAAgB,IAApB,EAA0B;AACxB;AACAD,IAAAA,GAAG,CAACC,OAAJ,GAAc,EAAd;AACAF,IAAAA,MAAM,CAACG,GAAP,CAAWC,KAAK,IAAI;AAClB;AACAH,MAAAA,GAAG,CAACC,OAAJ,CAAYG,IAAZ,CAAiB,IAAIC,+BAASC,KAAb,CAAmBH,KAAnB,CAAjB;AACD,KAHD;AAID,GAViE,CAYlE;;;AACA,wBAAU,MAAM;AACd,QAAIH,GAAG,CAACC,OAAR,EAAiB;AACfF,MAAAA,MAAM,CAACG,GAAP,CAAW,CAACC,KAAD,EAAQI,KAAR,KAAkB;AAC3B;AACA,YAAIP,GAAG,CAACC,OAAJ,CAAYM,KAAZ,CAAJ,EAAwB;AACtB;AACA;AACAP,UAAAA,GAAG,CAACC,OAAJ,CAAYM,KAAZ,EAAmBC,QAAnB,CAA4BL,KAA5B;AACD,SAJD,MAIO;AACL;AACA;AACAH,UAAAA,GAAG,CAACC,OAAJ,CAAYG,IAAZ,CAAiB,IAAIC,+BAASC,KAAb,CAAmBH,KAAnB,CAAjB;AACD;AACF,OAXD;AAaA;;;;;;AAKA,UAAIJ,MAAM,CAACU,MAAP,GAAgBT,GAAG,CAACC,OAAJ,CAAYQ,MAAhC,EAAwC;AACtC,cAAMC,SAAS,GAAGX,MAAM,CAACA,MAAM,CAACU,MAAP,GAAgB,CAAjB,CAAxB;;AACA,aAAK,IAAIE,CAAC,GAAGZ,MAAM,CAACU,MAAP,GAAgB,CAA7B,EAAgCE,CAAC,IAAIX,GAAG,CAACC,OAAJ,CAAYQ,MAAZ,GAAqB,CAA1D,EAA6DE,CAAC,EAA9D,EAAkE;AAChEX,UAAAA,GAAG,CAACC,OAAJ,CAAYU,CAAZ,EAAeH,QAAf,CAAwBE,SAAxB;AACD;AACF;AACF;AACF,GA3BD,EA2BG,CAACX,MAAD,CA3BH;AA6BA,SAAOC,GAAG,CAACC,OAAX;AACD,CA3CM","sourcesContent":["import { useEffect, useRef } from 'react';\nimport Animated from 'react-native-reanimated';\n\nexport const useReactiveValues = (values: ReadonlyArray<number>) => {\n  // ref\n  const ref = useRef<Animated.Value<number>[]>(null);\n  if (ref.current === null) {\n    // @ts-ignore\n    ref.current = [];\n    values.map(value => {\n      // @ts-ignore\n      ref.current.push(new Animated.Value(value));\n    });\n  }\n\n  // effects\n  useEffect(() => {\n    if (ref.current) {\n      values.map((value, index) => {\n        // @ts-ignore\n        if (ref.current[index]) {\n          // update current value\n          // @ts-ignore\n          ref.current[index].setValue(value);\n        } else {\n          // insert current value\n          // @ts-ignore\n          ref.current.push(new Animated.Value(value));\n        }\n      });\n\n      /**\n       * if previous animated array has more values than the updated\n       * array, we will need to set the extra values to the last\n       * value of the updated array.\n       */\n      if (values.length < ref.current.length) {\n        const lastValue = values[values.length - 1];\n        for (let i = values.length - 1; i <= ref.current.length - 1; i++) {\n          ref.current[i].setValue(lastValue);\n        }\n      }\n    }\n  }, [values]);\n\n  return ref.current!;\n};\n"]}
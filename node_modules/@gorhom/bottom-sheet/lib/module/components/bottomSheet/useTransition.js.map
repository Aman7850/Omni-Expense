{"version":3,"sources":["useTransition.ts"],"names":["useMemo","Animated","eq","set","add","greaterOrEq","lessOrEq","and","not","clockRunning","startClock","timing","stopClock","multiply","neq","onChange","or","cond","block","call","State","useClock","useValue","snapPoint","GESTURE","useReactiveValue","useReactiveValues","useTransition","animatedIsLayoutReady","animationDuration","animationEasing","contentPanGestureState","contentPanGestureTranslationY","contentPanGestureVelocityY","handlePanGestureState","handlePanGestureTranslationY","handlePanGestureVelocityY","scrollableContentOffsetY","snapPoints","_snapPoints","currentIndexRef","initialPosition","onAnimate","currentGesture","UNDETERMINED","currentPosition","isPanningContent","ACTIVE","isPanningHandle","isPanning","shouldAnimate","manualSnapToPoint","clock","config","toValue","Value","duration","easing","animationState","finished","position","frameTime","time","finishTiming","translateY","CONTENT","length","velocityY","isAnimationInterrupted","HANDLE","END","_toValue","_animatedSnapPoints","currentIndex","current","nextIndex","indexOf"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AACA,OAAOC,QAAP,IACEC,EADF,EAEEC,GAFF,EAGEC,GAHF,EAIEC,WAJF,EAKEC,QALF,EAMEC,GANF,EAOEC,GAPF,EAQEC,YARF,EASEC,UATF,EAUEC,MAVF,EAWEC,SAXF,EAYEC,QAZF,EAaEC,GAbF,EAcEC,QAdF,EAeEC,EAfF,EAgBEC,IAhBF,EAiBEC,KAjBF,EAkBEC,IAlBF,CAmBE;AAnBF,OAoBO,yBApBP;AAqBA,SAASC,KAAT,QAAsB,8BAAtB;AACA,SAASC,QAAT,EAAmBC,QAAnB,EAA6BC,SAA7B,QAA8C,qBAA9C;AACA,SAASC,OAAT,QAAwB,iBAAxB;AACA,SAASC,gBAAT,EAA2BC,iBAA3B,QAAoD,aAApD;AAGA,OAAO,MAAMC,aAAa,GAAG,CAAC;AAC5BC,EAAAA,qBAD4B;AAE5BC,EAAAA,iBAF4B;AAG5BC,EAAAA,eAH4B;AAI5BC,EAAAA,sBAJ4B;AAK5BC,EAAAA,6BAL4B;AAM5BC,EAAAA,0BAN4B;AAO5BC,EAAAA,qBAP4B;AAQ5BC,EAAAA,4BAR4B;AAS5BC,EAAAA,yBAT4B;AAU5BC,EAAAA,wBAV4B;AAW5BC,EAAAA,UAAU,EAAEC,WAXgB;AAY5BC,EAAAA,eAZ4B;AAa5BC,EAAAA,eAb4B;AAc5BC,EAAAA;AAd4B,CAAD,KAeM;AACjC,QAAMC,cAAc,GAAGrB,QAAQ,CAAUE,OAAO,CAACoB,YAAlB,CAA/B;AACA,QAAMC,eAAe,GAAGpB,gBAAgB,CAACgB,eAAD,CAAxC;AACA,QAAMH,UAAU,GAAGZ,iBAAiB,CAACa,WAAD,CAApC;AAEA,QAAMO,gBAAgB,GAAG9C,OAAO,CAC9B,MAAME,EAAE,CAAC6B,sBAAD,EAAyBX,KAAK,CAAC2B,MAA/B,CADsB,EAE9B,CAAChB,sBAAD,CAF8B,CAAhC;AAIA,QAAMiB,eAAe,GAAGhD,OAAO,CAC7B,MAAME,EAAE,CAACgC,qBAAD,EAAwBd,KAAK,CAAC2B,MAA9B,CADqB,EAE7B,CAACb,qBAAD,CAF6B,CAA/B;AAIA,QAAMe,SAAS,GAAGjD,OAAO,CAAC,MAAMgB,EAAE,CAAC8B,gBAAD,EAAmBE,eAAnB,CAAT,EAA8C,CACrEF,gBADqE,EAErEE,eAFqE,CAA9C,CAAzB;AAIA,QAAME,aAAa,GAAG5B,QAAQ,CAAC,CAAD,CAA9B;AACA,QAAM6B,iBAAiB,GAAG7B,QAAQ,CAAS,CAAC,CAAV,CAAlC;AAEA,QAAM8B,KAAK,GAAG/B,QAAQ,EAAtB;AACA,QAAMgC,MAAM,GAAGrD,OAAO,CACpB,OAAO;AACLsD,IAAAA,OAAO,EAAE,IAAIrD,QAAQ,CAACsD,KAAb,CAAmB,CAAC,CAApB,CADJ;AAELC,IAAAA,QAAQ,EAAE3B,iBAFL;AAGL4B,IAAAA,MAAM,EAAE3B;AAHH,GAAP,CADoB,EAMpB,CAACA,eAAD,EAAkBD,iBAAlB,CANoB,CAAtB;AASA,QAAM6B,cAAc,GAAG1D,OAAO,CAC5B,OAAO;AACL2D,IAAAA,QAAQ,EAAE,IAAI1D,QAAQ,CAACsD,KAAb,CAAmB,CAAnB,CADL;AAELK,IAAAA,QAAQ,EAAE,IAAI3D,QAAQ,CAACsD,KAAb,CAAmBd,eAAnB,CAFL;AAGLoB,IAAAA,SAAS,EAAE,IAAI5D,QAAQ,CAACsD,KAAb,CAAmB,CAAnB,CAHN;AAILO,IAAAA,IAAI,EAAE,IAAI7D,QAAQ,CAACsD,KAAb,CAAmB,CAAnB;AAJD,GAAP,CAD4B,EAO5B;AACA,IAR4B,CAA9B;AAWA,QAAMQ,YAAY,GAAG/D,OAAO,CAC1B,MAAM,CACJ;AACAG,EAAAA,GAAG,CAACwC,cAAD,EAAiBnB,OAAO,CAACoB,YAAzB,CAFC,EAGJzC,GAAG,CAAC+C,aAAD,EAAgB,CAAhB,CAHC,EAIJ/C,GAAG,CAAC0C,eAAD,EAAkBQ,MAAM,CAACC,OAAzB,CAJC,EAKJnD,GAAG,CAACuD,cAAc,CAACG,SAAhB,EAA2B,CAA3B,CALC,EAMJ1D,GAAG,CAACuD,cAAc,CAACI,IAAhB,EAAsB,CAAtB,CANC,EAOJlD,SAAS,CAACwC,KAAD,CAPL,CADoB,EAU1B,CACEM,cAAc,CAACG,SADjB,EAEEH,cAAc,CAACI,IAFjB,EAGEV,KAHF,EAIEC,MAAM,CAACC,OAJT,EAKEX,cALF,EAMEE,eANF,EAOEK,aAPF,CAV0B,CAA5B;AAqBA,QAAMc,UAAU,GAAGhE,OAAO,CACxB,MACEiB,IAAI,CACFf,EAAE,CAACyC,cAAD,EAAiBnB,OAAO,CAACyC,OAAzB,CADA,EAEFhD,IAAI,CACFf,EAAE,CAAC2C,eAAD,EAAkBP,UAAU,CAACA,UAAU,CAAC4B,MAAX,GAAoB,CAArB,CAA5B,CADA,EAEF9D,GAAG,CACD4B,6BADC,EAEDnB,QAAQ,CAACwB,wBAAD,EAA2B,CAAC,CAA5B,CAFP,CAFD,EAMFL,6BANE,CAFF,EAUFG,4BAVE,CAFkB,EAcxB,CACEG,UADF,EAEEK,cAFF,EAGEE,eAHF,EAIEb,6BAJF,EAKEG,4BALF,EAMEE,wBANF,CAdwB,CAA1B;AAuBA,QAAM8B,SAAS,GAAGnE,OAAO,CACvB,MACEiB,IAAI,CACFf,EAAE,CAACyC,cAAD,EAAiBnB,OAAO,CAACyC,OAAzB,CADA,EAEFhC,0BAFE,EAGFG,yBAHE,CAFiB,EAOvB,CAACH,0BAAD,EAA6BG,yBAA7B,EAAwDO,cAAxD,CAPuB,CAAzB;AASA,QAAMyB,sBAAsB,GAAGpE,OAAO,CACpC,MACEO,GAAG,CACDE,YAAY,CAAC2C,KAAD,CADX,EAEDpC,EAAE,CACAiC,SADA,EAEA1C,GAAG,CACDO,GAAG,CAACqC,iBAAD,EAAoB,CAAC,CAArB,CADF,EAEDrC,GAAG,CAACqC,iBAAD,EAAoBE,MAAM,CAACC,OAA3B,CAFF,CAFH,CAFD,CAF+B,EAYpC,CAACF,KAAD,EAAQH,SAAR,EAAmBI,MAAM,CAACC,OAA1B,EAAmCH,iBAAnC,CAZoC,CAAtC;AAcA,QAAMS,QAAQ,GAAG5D,OAAO,CACtB,MACEkB,KAAK,CAAC,CACJD,IAAI,CACFW,qBADE,EAEF,CACE;;AACA;;;;AAIAX,EAAAA,IAAI,CAACmD,sBAAD,EAAyB,CAC3B;AACAL,EAAAA,YAF2B,EAG3B5D,GAAG,CAAC0C,eAAD,EAAkBa,cAAc,CAACE,QAAjC,CAHwB,CAAzB,CANN;AAYE;;;AAGA3C,EAAAA,IAAI,CAACgC,SAAD,EAAY,CACd9C,GAAG,CACDwC,cADC,EAED1B,IAAI,CAAC6B,gBAAD,EAAmBtB,OAAO,CAACyC,OAA3B,EAAoCzC,OAAO,CAAC6C,MAA5C,CAFH,CADW,EAKd;AACApD,EAAAA,IAAI,CACFT,GAAG,CACDH,WAAW,CACTD,GAAG,CAACyC,eAAD,EAAkBmB,UAAlB,CADM,EAET1B,UAAU,CAACA,UAAU,CAAC4B,MAAX,GAAoB,CAArB,CAFD,CADV,CADD,EAOF,CACE/D,GAAG,CACDuD,cAAc,CAACE,QADd,EAEDtB,UAAU,CAACA,UAAU,CAAC4B,MAAX,GAAoB,CAArB,CAFT,CADL,EAKE/D,GAAG,CAACuD,cAAc,CAACC,QAAhB,EAA0B,CAA1B,CALL,CAPE,EAcF1C,IAAI,CACFT,GAAG,CACDF,QAAQ,CAACF,GAAG,CAACyC,eAAD,EAAkBmB,UAAlB,CAAJ,EAAmC1B,UAAU,CAAC,CAAD,CAA7C,CADP,CADD,EAIF,CACEnC,GAAG,CAACuD,cAAc,CAACE,QAAhB,EAA0BtB,UAAU,CAAC,CAAD,CAApC,CADL,EAEEnC,GAAG,CAACuD,cAAc,CAACC,QAAhB,EAA0B,CAA1B,CAFL,CAJE,EAQF,CACExD,GAAG,CACDuD,cAAc,CAACE,QADd,EAEDxD,GAAG,CAACyC,eAAD,EAAkBmB,UAAlB,CAFF,CADL,EAKE7D,GAAG,CAACuD,cAAc,CAACC,QAAhB,EAA0B,CAA1B,CALL,CARE,CAdF,CANU,CAAZ,CAfN;AAsDE;;;AAGA5C,EAAAA,QAAQ,CACNX,GAAG,CAAC2B,sBAAD,EAAyBG,qBAAzB,CADG,EAENjB,IAAI,CACFD,EAAE,CACAT,GAAG,CACDL,EAAE,CAACyC,cAAD,EAAiBnB,OAAO,CAACyC,OAAzB,CADD,EAED/D,EAAE,CAAC6B,sBAAD,EAAyBX,KAAK,CAACkD,GAA/B,CAFD,CADH,EAKA/D,GAAG,CACDL,EAAE,CAACyC,cAAD,EAAiBnB,OAAO,CAAC6C,MAAzB,CADD,EAEDnE,EAAE,CAACgC,qBAAD,EAAwBd,KAAK,CAACkD,GAA9B,CAFD,CALH,CADA,EAWF,CACE;AACAnE,EAAAA,GAAG,CACDkD,MAAM,CAACC,OADN,EAED/B,SAAS,CACPnB,GAAG,CAACyC,eAAD,EAAkBmB,UAAlB,CADI,EAEPG,SAFO,EAGP7B,UAHO,CAFR,CAFL;AAUE;;;AAGArB,EAAAA,IAAI,CACFH,GAAG,CAACuC,MAAM,CAACC,OAAR,EAAiBI,cAAc,CAACE,QAAhC,CADD,EAEFzD,GAAG,CAAC+C,aAAD,EAAgB,CAAhB,CAFD,EAGFa,YAHE,CAbN,CAXE,CAFE,CAzDV;AA4FE;;;AAGA9C,EAAAA,IAAI,CACFV,GAAG,CACDO,GAAG,CAACqC,iBAAD,EAAoB,CAAC,CAArB,CADF,EAEDnC,EAAE,CACAF,GAAG,CAACqC,iBAAD,EAAoBN,eAApB,CADH,EAEA/B,GAAG,CAACqC,iBAAD,EAAoBO,cAAc,CAACE,QAAnC,CAFH,CAFD,EAMD9C,GAAG,CAACqC,iBAAD,EAAoBE,MAAM,CAACC,OAA3B,CANF,CADD,EASF,CACE;AACAnD,EAAAA,GAAG,CAACkD,MAAM,CAACC,OAAR,EAAiBH,iBAAjB,CAFL,EAGEhD,GAAG,CAACuD,cAAc,CAACC,QAAhB,EAA0B,CAA1B,CAHL,EAIExD,GAAG,CAAC+C,aAAD,EAAgB,CAAhB,CAJL,EAKE/C,GAAG,CAACgD,iBAAD,EAAoB,CAAC,CAArB,CALL,CATE,EAgBFhD,GAAG,CAACgD,iBAAD,EAAoB,CAAC,CAArB,CAhBD,CA/FN;AAkHE;;;AAGAlC,EAAAA,IAAI,CAACiC,aAAD,EAAgB,CAClB;AACAjC,EAAAA,IAAI,CACFV,GAAG,CAACC,GAAG,CAACC,YAAY,CAAC2C,KAAD,CAAb,CAAJ,EAA2B5C,GAAG,CAACkD,cAAc,CAACC,QAAhB,CAA9B,CADD,EAEF,CACE;;AACA;;;AAGAxC,EAAAA,IAAI,CACF,CAACkC,MAAM,CAACC,OAAR,EAAiB,GAAGhB,UAApB,CADE,EAEF,CAAC,CAACiC,QAAD,EAAW,GAAGC,mBAAd,CAAD,KAAwC;AACtC,UAAMC,YAAY,GAAGjC,eAAe,CAACkC,OAArC;;AACA,UAAMC,SAAS,GAAGH,mBAAmB,CAACI,OAApB,CAA4BL,QAA5B,CAAlB;;AAEA,QAAI7B,SAAJ,EAAe;AACbA,MAAAA,SAAS,CAAC+B,YAAD,EAAeE,SAAf,CAAT;AACD;AACF,GATC,CALN,EAiBExE,GAAG,CAACuD,cAAc,CAACC,QAAhB,EAA0B,CAA1B,CAjBL,EAkBExD,GAAG,CAACuD,cAAc,CAACG,SAAhB,EAA2B,CAA3B,CAlBL,EAmBE1D,GAAG,CAACuD,cAAc,CAACI,IAAhB,EAAsB,CAAtB,CAnBL,EAoBEpD,UAAU,CAAC0C,KAAD,CApBZ,CAFE,CAFc,EA2BlBzC,MAAM,CAACyC,KAAD,EAAQM,cAAR,EAAwBL,MAAxB,CA3BY,EA4BlBpC,IAAI,CAACyC,cAAc,CAACC,QAAhB,EAA0BI,YAA1B,CA5Bc,CAAhB,CArHN,EAoJEL,cAAc,CAACE,QApJjB,CAFE,EAwJF,CAxJE,CADA,CAAD,CAFe,EA8JtB,CACEhC,qBADF,EAEE8B,cAFF,EAGEN,KAHF,EAIEC,MAJF,EAKEV,cALF,EAMEE,eANF,EAOEkB,YAPF,EAQEK,sBARF,EASEnB,SATF,EAUEH,gBAVF,EAWEK,iBAXF,EAYED,aAZF,EAaEZ,UAbF,EAcE0B,UAdF,EAeEG,SAfF,EAgBEpC,sBAhBF,EAiBEG,qBAjBF,EAkBEM,eAlBF,EAmBEE,SAnBF,CA9JsB,CAAxB;AAqLA,SAAO;AACLkB,IAAAA,QADK;AAELI,IAAAA,UAFK;AAGLb,IAAAA,iBAHK;AAILN,IAAAA,eAJK;AAKLF,IAAAA;AALK,GAAP;AAOD,CAvTM","sourcesContent":["import { useMemo } from 'react';\nimport Animated, {\n  eq,\n  set,\n  add,\n  greaterOrEq,\n  lessOrEq,\n  and,\n  not,\n  clockRunning,\n  startClock,\n  timing,\n  stopClock,\n  multiply,\n  neq,\n  onChange,\n  or,\n  cond,\n  block,\n  call,\n  // debug,\n} from 'react-native-reanimated';\nimport { State } from 'react-native-gesture-handler';\nimport { useClock, useValue, snapPoint } from 'react-native-redash';\nimport { GESTURE } from '../../constants';\nimport { useReactiveValue, useReactiveValues } from '../../hooks';\nimport type { BottomSheetTransitionConfig } from './types';\n\nexport const useTransition = ({\n  animatedIsLayoutReady,\n  animationDuration,\n  animationEasing,\n  contentPanGestureState,\n  contentPanGestureTranslationY,\n  contentPanGestureVelocityY,\n  handlePanGestureState,\n  handlePanGestureTranslationY,\n  handlePanGestureVelocityY,\n  scrollableContentOffsetY,\n  snapPoints: _snapPoints,\n  currentIndexRef,\n  initialPosition,\n  onAnimate,\n}: BottomSheetTransitionConfig) => {\n  const currentGesture = useValue<GESTURE>(GESTURE.UNDETERMINED);\n  const currentPosition = useReactiveValue(initialPosition);\n  const snapPoints = useReactiveValues(_snapPoints);\n\n  const isPanningContent = useMemo(\n    () => eq(contentPanGestureState, State.ACTIVE),\n    [contentPanGestureState]\n  );\n  const isPanningHandle = useMemo(\n    () => eq(handlePanGestureState, State.ACTIVE),\n    [handlePanGestureState]\n  );\n  const isPanning = useMemo(() => or(isPanningContent, isPanningHandle), [\n    isPanningContent,\n    isPanningHandle,\n  ]);\n  const shouldAnimate = useValue(0);\n  const manualSnapToPoint = useValue<number>(-1);\n\n  const clock = useClock();\n  const config = useMemo(\n    () => ({\n      toValue: new Animated.Value(-1),\n      duration: animationDuration,\n      easing: animationEasing,\n    }),\n    [animationEasing, animationDuration]\n  );\n\n  const animationState = useMemo(\n    () => ({\n      finished: new Animated.Value(0),\n      position: new Animated.Value(initialPosition),\n      frameTime: new Animated.Value(0),\n      time: new Animated.Value(0),\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const finishTiming = useMemo(\n    () => [\n      // debug('finish timing', config.toValue),\n      set(currentGesture, GESTURE.UNDETERMINED),\n      set(shouldAnimate, 0),\n      set(currentPosition, config.toValue),\n      set(animationState.frameTime, 0),\n      set(animationState.time, 0),\n      stopClock(clock),\n    ],\n    [\n      animationState.frameTime,\n      animationState.time,\n      clock,\n      config.toValue,\n      currentGesture,\n      currentPosition,\n      shouldAnimate,\n    ]\n  );\n\n  const translateY = useMemo(\n    () =>\n      cond(\n        eq(currentGesture, GESTURE.CONTENT),\n        cond(\n          eq(currentPosition, snapPoints[snapPoints.length - 1]),\n          add(\n            contentPanGestureTranslationY,\n            multiply(scrollableContentOffsetY, -1)\n          ),\n          contentPanGestureTranslationY\n        ),\n        handlePanGestureTranslationY\n      ),\n    [\n      snapPoints,\n      currentGesture,\n      currentPosition,\n      contentPanGestureTranslationY,\n      handlePanGestureTranslationY,\n      scrollableContentOffsetY,\n    ]\n  );\n  const velocityY = useMemo(\n    () =>\n      cond(\n        eq(currentGesture, GESTURE.CONTENT),\n        contentPanGestureVelocityY,\n        handlePanGestureVelocityY\n      ),\n    [contentPanGestureVelocityY, handlePanGestureVelocityY, currentGesture]\n  );\n  const isAnimationInterrupted = useMemo(\n    () =>\n      and(\n        clockRunning(clock),\n        or(\n          isPanning,\n          and(\n            neq(manualSnapToPoint, -1),\n            neq(manualSnapToPoint, config.toValue)\n          )\n        )\n      ),\n    [clock, isPanning, config.toValue, manualSnapToPoint]\n  );\n  const position = useMemo(\n    () =>\n      block([\n        cond(\n          animatedIsLayoutReady,\n          [\n            // debug('current gesture', currentGesture),\n            /**\n             * In case animation get interrupted, we execute the finishTiming node and\n             * set current position the the animated position.\n             */\n            cond(isAnimationInterrupted, [\n              // debug('animation interrupted', isAnimationInterrupted),\n              finishTiming,\n              set(currentPosition, animationState.position),\n            ]),\n\n            /**\n             * Panning node\n             */\n            cond(isPanning, [\n              set(\n                currentGesture,\n                cond(isPanningContent, GESTURE.CONTENT, GESTURE.HANDLE)\n              ),\n              // debug('start panning', translateY),\n              cond(\n                not(\n                  greaterOrEq(\n                    add(currentPosition, translateY),\n                    snapPoints[snapPoints.length - 1]\n                  )\n                ),\n                [\n                  set(\n                    animationState.position,\n                    snapPoints[snapPoints.length - 1]\n                  ),\n                  set(animationState.finished, 0),\n                ],\n                cond(\n                  not(\n                    lessOrEq(add(currentPosition, translateY), snapPoints[0])\n                  ),\n                  [\n                    set(animationState.position, snapPoints[0]),\n                    set(animationState.finished, 0),\n                  ],\n                  [\n                    set(\n                      animationState.position,\n                      add(currentPosition, translateY)\n                    ),\n                    set(animationState.finished, 0),\n                  ]\n                )\n              ),\n            ]),\n\n            /**\n             * Gesture ended node.\n             */\n            onChange(\n              add(contentPanGestureState, handlePanGestureState),\n              cond(\n                or(\n                  and(\n                    eq(currentGesture, GESTURE.CONTENT),\n                    eq(contentPanGestureState, State.END)\n                  ),\n                  and(\n                    eq(currentGesture, GESTURE.HANDLE),\n                    eq(handlePanGestureState, State.END)\n                  )\n                ),\n                [\n                  // debug('gesture end', currentGesture),\n                  set(\n                    config.toValue,\n                    snapPoint(\n                      add(currentPosition, translateY),\n                      velocityY,\n                      snapPoints\n                    )\n                  ),\n                  /**\n                   * here we make sure that captured gesture was not the content scrolling.\n                   */\n                  cond(\n                    neq(config.toValue, animationState.position),\n                    set(shouldAnimate, 1),\n                    finishTiming\n                  ),\n                ]\n              )\n            ),\n\n            /**\n             * Manual snapping node.\n             */\n            cond(\n              and(\n                neq(manualSnapToPoint, -1),\n                or(\n                  neq(manualSnapToPoint, currentPosition),\n                  neq(manualSnapToPoint, animationState.position)\n                ),\n                neq(manualSnapToPoint, config.toValue)\n              ),\n              [\n                // debug('manualSnapToPoint', manualSnapToPoint),\n                set(config.toValue, manualSnapToPoint),\n                set(animationState.finished, 0),\n                set(shouldAnimate, 1),\n                set(manualSnapToPoint, -1),\n              ],\n              set(manualSnapToPoint, -1)\n            ),\n\n            /**\n             * Animation Node.\n             */\n            cond(shouldAnimate, [\n              // debug('animating', shouldAnimate),\n              cond(\n                and(not(clockRunning(clock)), not(animationState.finished)),\n                [\n                  // debug('start animating', shouldAnimate),\n                  /**\n                   * `onAnimate` node\n                   */\n                  call(\n                    [config.toValue, ...snapPoints],\n                    ([_toValue, ..._animatedSnapPoints]) => {\n                      const currentIndex = currentIndexRef.current!;\n                      const nextIndex = _animatedSnapPoints.indexOf(_toValue);\n\n                      if (onAnimate) {\n                        onAnimate(currentIndex, nextIndex);\n                      }\n                    }\n                  ),\n\n                  set(animationState.finished, 0),\n                  set(animationState.frameTime, 0),\n                  set(animationState.time, 0),\n                  startClock(clock),\n                ]\n              ),\n              timing(clock, animationState, config),\n              cond(animationState.finished, finishTiming),\n            ]),\n\n            animationState.position,\n          ],\n          0\n        ),\n      ]),\n    [\n      animatedIsLayoutReady,\n      animationState,\n      clock,\n      config,\n      currentGesture,\n      currentPosition,\n      finishTiming,\n      isAnimationInterrupted,\n      isPanning,\n      isPanningContent,\n      manualSnapToPoint,\n      shouldAnimate,\n      snapPoints,\n      translateY,\n      velocityY,\n      contentPanGestureState,\n      handlePanGestureState,\n      currentIndexRef,\n      onAnimate,\n    ]\n  );\n\n  return {\n    position,\n    translateY,\n    manualSnapToPoint,\n    currentPosition,\n    currentGesture,\n  };\n};\n"]}
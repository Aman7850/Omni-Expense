{"version":3,"sources":["useReactiveValues.ts"],"names":["useEffect","useRef","Animated","useReactiveValues","values","ref","current","map","value","push","Value","index","setValue","length","lastValue","i"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AACA,OAAOC,QAAP,MAAqB,yBAArB;AAEA,OAAO,MAAMC,iBAAiB,GAAIC,MAAD,IAAmC;AAClE;AACA,QAAMC,GAAG,GAAGJ,MAAM,CAA2B,IAA3B,CAAlB;;AACA,MAAII,GAAG,CAACC,OAAJ,KAAgB,IAApB,EAA0B;AACxB;AACAD,IAAAA,GAAG,CAACC,OAAJ,GAAc,EAAd;AACAF,IAAAA,MAAM,CAACG,GAAP,CAAWC,KAAK,IAAI;AAClB;AACAH,MAAAA,GAAG,CAACC,OAAJ,CAAYG,IAAZ,CAAiB,IAAIP,QAAQ,CAACQ,KAAb,CAAmBF,KAAnB,CAAjB;AACD,KAHD;AAID,GAViE,CAYlE;;;AACAR,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIK,GAAG,CAACC,OAAR,EAAiB;AACfF,MAAAA,MAAM,CAACG,GAAP,CAAW,CAACC,KAAD,EAAQG,KAAR,KAAkB;AAC3B;AACA,YAAIN,GAAG,CAACC,OAAJ,CAAYK,KAAZ,CAAJ,EAAwB;AACtB;AACA;AACAN,UAAAA,GAAG,CAACC,OAAJ,CAAYK,KAAZ,EAAmBC,QAAnB,CAA4BJ,KAA5B;AACD,SAJD,MAIO;AACL;AACA;AACAH,UAAAA,GAAG,CAACC,OAAJ,CAAYG,IAAZ,CAAiB,IAAIP,QAAQ,CAACQ,KAAb,CAAmBF,KAAnB,CAAjB;AACD;AACF,OAXD;AAaA;;;;;;AAKA,UAAIJ,MAAM,CAACS,MAAP,GAAgBR,GAAG,CAACC,OAAJ,CAAYO,MAAhC,EAAwC;AACtC,cAAMC,SAAS,GAAGV,MAAM,CAACA,MAAM,CAACS,MAAP,GAAgB,CAAjB,CAAxB;;AACA,aAAK,IAAIE,CAAC,GAAGX,MAAM,CAACS,MAAP,GAAgB,CAA7B,EAAgCE,CAAC,IAAIV,GAAG,CAACC,OAAJ,CAAYO,MAAZ,GAAqB,CAA1D,EAA6DE,CAAC,EAA9D,EAAkE;AAChEV,UAAAA,GAAG,CAACC,OAAJ,CAAYS,CAAZ,EAAeH,QAAf,CAAwBE,SAAxB;AACD;AACF;AACF;AACF,GA3BQ,EA2BN,CAACV,MAAD,CA3BM,CAAT;AA6BA,SAAOC,GAAG,CAACC,OAAX;AACD,CA3CM","sourcesContent":["import { useEffect, useRef } from 'react';\nimport Animated from 'react-native-reanimated';\n\nexport const useReactiveValues = (values: ReadonlyArray<number>) => {\n  // ref\n  const ref = useRef<Animated.Value<number>[]>(null);\n  if (ref.current === null) {\n    // @ts-ignore\n    ref.current = [];\n    values.map(value => {\n      // @ts-ignore\n      ref.current.push(new Animated.Value(value));\n    });\n  }\n\n  // effects\n  useEffect(() => {\n    if (ref.current) {\n      values.map((value, index) => {\n        // @ts-ignore\n        if (ref.current[index]) {\n          // update current value\n          // @ts-ignore\n          ref.current[index].setValue(value);\n        } else {\n          // insert current value\n          // @ts-ignore\n          ref.current.push(new Animated.Value(value));\n        }\n      });\n\n      /**\n       * if previous animated array has more values than the updated\n       * array, we will need to set the extra values to the last\n       * value of the updated array.\n       */\n      if (values.length < ref.current.length) {\n        const lastValue = values[values.length - 1];\n        for (let i = values.length - 1; i <= ref.current.length - 1; i++) {\n          ref.current[i].setValue(lastValue);\n        }\n      }\n    }\n  }, [values]);\n\n  return ref.current!;\n};\n"]}